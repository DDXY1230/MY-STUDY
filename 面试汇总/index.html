<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1. get  和 post 的区别？ 
        /**
        * get：数据放在url里面进行传输  
            大小不超过32k  
            因为url在报文的头部，
            所以get请求是在报文的头部
            在node中直接读取url即可

          post：放在报文的body主体，
            容量大不超过2G即可
            可分段传输
            在node中req.on('data',(buffer)=>{})读取
            
        */

        // 分割线---------------------------
        
        // 2. 写一个防抖函数
        function debounce(func, wait) {
            let timeout
            return function () {
                let context = this
                let args = arguments

                if (timeout) clearTimeout(timeout)

                timeout = setTimeout(() => {
                    func.apply(context, args)
                }, wait)
            }
        }

        function debounce_1(func, wait) {
            let timeout
            return function () {
                let context = this
                let args = arguments

                let callNow = !timeout
                if (callNow) func.apply(context, args)

                if (timeout) clearTimeout(timeout)
                timeout = setTimeout(() => {
                    timeout = null
                }, wait)
            }
        }
        // 3. promise源码有没有了解过?
        /**
         * 每次返回的是一个新的promise，
         * 因为状态一旦确定就没办法改了
         */
        // -----------------------------------------------
        
        // 4. 说一说闭包 
        /**
         * 比如说函数里面返回一个函数，内部函数可以访问外部函数的变量
         * 就形成了闭包，正常函数执行完，里面申明的变量会被垃圾回收掉，但是闭包可以让
         * 作用域里面的变量在函数执行完依旧保持没有被垃圾回收的状态
         * function foo() {
         * let name = 'kk'
         * return function() {
         * cosole.log(name)
         * }
         * }
         * 闭包可能会导致内存占用过高，因为变量没有被释放
         */
        // -----------------------------------------------

        // 5. 垃圾回收机制 
        /**
         * js有一套自己的垃圾回收机制，当检测到一个对象何时不再使用的
         * 时候，他就会不再需要这个对象，便把它占用的内存释放出来
         * 各大浏览器采用的垃圾回收机制有两种方法：标记清除   引用计数
         * 当变量被执行时，被标记：进入环境，永远不可能删除进入环境的
         * 变量所占的内存，因为你会被用到，当被变量离开环境的时候，标记：离开环境
         * 会被垃圾收集器清除，回收他们所占用的空间
         * 引用计数是跟踪记录每个值所引用的次数，当被引用的时候1 反之为0
         * 垃圾收集器运行时，就会释放那些引用计数为0的值所占用的内存
         * 有些循环引用的不可能为0 的将导致大量的内存泄漏，解决的方式是：变量=null，
         * 手动切断循环引用
         * 
         * 
         */
        // -----------------------------------------------

        // 6.宏任务和微任务
        //   宏任务是由宿主（浏览器/node）发起的，如setTimeout\setInterval\setInneediate\I/O
        //   微任务：js引擎发起的如Promise

        // 7.继承的几种方式
        /**
         * 1）原型链继承：将子类的原型链指向父类的实力对象
         *   function Parent() {
         *      this.name = 'parent'
         *      this.list = ['a']
         * }
         * Parent.prototype.sayHi = function() {
         *  console.log('hi')
         * }
         * 
         * function Child() {
         * 
         * }
         * Child.prototype = new Parent()
         * let child = new Child()
         * conosle.log(child.name)
         * child.sayHi()
         * 2)构造函数继承：在子类构造函数中使用call或者apply劫持父类构造函数，并且传入参数
         * 3）组合继承：综合使用构造函数和原型链继承
         * 4）原型式继承
         * 5）寄生式继承：二次封装原型式继承
         * 6）寄生组合式继承：
         * 
         * 
         * 
        */
        // -----------------------------------------------

        // 8.webpack的实现原理
        // -----------------------------------------------

        // 9.intansof的实现原理
        // -----------------------------------------------

        // 10.事件循环（eventloop)
        /**
         * 主线程从‘任务队列’中读取事件这个过程是循环不断的，所以这个的这种机制又称为
         * 事件循环（eventloop）
         * */
        // -----------------------------------------------

        // 11.promise all 的原理
        // -----------------------------------------------

        // 12.v-model 的原理
            /**
             * 即绑定了数据，又添加了事件监听
            */
        // -----------------------------------------------

        // 13.vuex 的实现原理
        /**
         * 不像其他的状态管理器redux mobx等可以使用在其他的框架中，
         * vuex只能使用在vue上，很大的程度是因为高度依赖于vue的competed
         * 依赖检测系统以及插件系统
         * 完完全全的使用了vue自身的响应式设计，依赖监听，依赖收集都属于vue对象property set get
         * 方法的代理劫持
         * 本质是将我们传入的state作为隐藏的vue组件的data，我们的commit操作本质上
         * 是修改组件的data值
         * 结合上下文的computed修改被defineReactive代理的对象值后，会将其
         * 收集到的依赖的watcher中的dirty改为true，等到下次访问该watcher值重新获取新的值
         * 这样就解释了vuex中的state的对象必须提前定义好，如果state中途增加一个属性，因为
         * 该属性没有被defaneReactive，所以依赖系统没有检测到，自然不能更新
        */
        // -----------------------------------------------

        // 14.$set的实现原理
        // -----------------------------------------------

        // 15.做过那些性能优化
        // -----------------------------------------------

        // 16.重排和重绘
        // -----------------------------------------------

        // 17.vue自定义指令
        // -----------------------------------------------

        // 18.vue传值的方式
        // -----------------------------------------------

        // 19.webpack lader的使用方式
        // -----------------------------------------------

        // 20.webpack 插件的使用方式
        // -----------------------------------------------

        // 21.防抖 
        // -----------------------------------------------

        // 22.闭包
        // -----------------------------------------------

        // 23.箭头函数和普通函数的区别
        // -----------------------------------------------

        // 24.居中的几种方式
        // -----------------------------------------------

        // 25.浮动和绝对定位都脱离文档流 两者的区别
        // -----------------------------------------------

        // 26.flex布局
        // -----------------------------------------------

        // 27.订阅发布模式
        // -----------------------------------------------

        // 28.是否写过vue插件
        // -----------------------------------------------

        // 29.cookie 和 loacalstorage 和 sessionstorage的区别
        // -----------------------------------------------
        
        // 30.盒模型
        // -----------------------------------------------

        // 31.基本数据类型和引用数据类型的区别
        // -----------------------------------------------

    </script>
</body>

</html>