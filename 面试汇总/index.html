<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1. get  和 post 的区别？ 
        /**
        * get：数据放在url里面进行传输  
            大小不超过32k  
            因为url在报文的头部，
            所以get请求是在报文的头部
            在node中直接读取url即可

          post：放在报文的body主体，
            容量大不超过2G即可
            可分段传输
            在node中req.on('data',(buffer)=>{})读取
            
        */

        // 分割线---------------------------

        // 2. 写一个防抖函数
        function debounce(func, wait) {
            let timeout
            return function () {
                let context = this
                let args = arguments

                if (timeout) clearTimeout(timeout)

                timeout = setTimeout(() => {
                    func.apply(context, args)
                }, wait)
            }
        }

        function debounce_1(func, wait) {
            let timeout
            return function () {
                let context = this
                let args = arguments

                let callNow = !timeout
                if (callNow) func.apply(context, args)

                if (timeout) clearTimeout(timeout)
                timeout = setTimeout(() => {
                    timeout = null
                }, wait)
            }
        }
        // 3. promise源码有没有了解过?
        /**
         * 每次返回的是一个新的promise，
         * 因为状态一旦确定就没办法改了
         */
        // -----------------------------------------------

        // 4. 说一说闭包 
        /**
         * 比如说函数里面返回一个函数，内部函数可以访问外部函数的变量
         * 就形成了闭包，正常函数执行完，里面申明的变量会被垃圾回收掉，但是闭包可以让
         * 作用域里面的变量在函数执行完依旧保持没有被垃圾回收的状态
         * function foo() {
         * let name = 'kk'
         * return function() {
         * cosole.log(name)
         * }
         * }
         * 闭包可能会导致内存占用过高，因为变量没有被释放
         */
        // -----------------------------------------------

        // 5. 垃圾回收机制 
        /**
         * js有一套自己的垃圾回收机制，当检测到一个对象何时不再使用的
         * 时候，他就会不再需要这个对象，便把它占用的内存释放出来
         * 各大浏览器采用的垃圾回收机制有两种方法：标记清除   引用计数
         * 当变量被执行时，被标记：进入环境，永远不可能删除进入环境的
         * 变量所占的内存，因为你会被用到，当被变量离开环境的时候，标记：离开环境
         * 会被垃圾收集器清除，回收他们所占用的空间
         * 引用计数是跟踪记录每个值所引用的次数，当被引用的时候1 反之为0
         * 垃圾收集器运行时，就会释放那些引用计数为0的值所占用的内存
         * 有些循环引用的不可能为0 的将导致大量的内存泄漏，解决的方式是：变量=null，
         * 手动切断循环引用
         * 
         * 
         */
        // -----------------------------------------------

        // 6.宏任务和微任务
        //   宏任务是由宿主（浏览器/node）发起的，如setTimeout\setInterval\setInneediate\I/O
        //   微任务：js引擎发起的如Promise

        // 7.继承的几种方式
        /**
         * 1）原型链继承：将子类的原型链指向父类的实力对象
         *   function Parent() {
         *      this.name = 'parent'
         *      this.list = ['a']
         * }
         * Parent.prototype.sayHi = function() {
         *  console.log('hi')
         * }
         * 
         * function Child() {
         * 
         * }
         * Child.prototype = new Parent()
         * let child = new Child()
         * conosle.log(child.name)
         * child.sayHi()
         * 2)构造函数继承：在子类构造函数中使用call或者apply劫持父类构造函数，并且传入参数
         * 3）组合继承：综合使用构造函数和原型链继承
         * 4）原型式继承
         * 5）寄生式继承：二次封装原型式继承
         * 6）寄生组合式继承：
         * 
         * 
         * 
         */
        // -----------------------------------------------

        // 8.webpack的实现原理
        // -----------------------------------------------

        // 9.intansof的实现原理
        // -----------------------------------------------

        // 10.事件循环（eventloop)
        /**
         * 主线程从‘任务队列’中读取事件这个过程是循环不断的，所以这个的这种机制又称为
         * 事件循环（eventloop）
         * */
        // -----------------------------------------------

        // 11.promise all 的原理
        // -----------------------------------------------

        // 12.v-model 的原理
        /**
         * 即绑定了数据，又添加了事件监听
         */
        // -----------------------------------------------

        // 13.vuex 的实现原理
        /**
         * 不像其他的状态管理器redux mobx等可以使用在其他的框架中，
         * vuex只能使用在vue上，很大的程度是因为高度依赖于vue的competed
         * 依赖检测系统以及插件系统
         * 完完全全的使用了vue自身的响应式设计，依赖监听，依赖收集都属于vue对象property set get
         * 方法的代理劫持
         * 本质是将我们传入的state作为隐藏的vue组件的data，我们的commit操作本质上
         * 是修改组件的data值
         * 结合上下文的computed修改被defineReactive代理的对象值后，会将其
         * 收集到的依赖的watcher中的dirty改为true，等到下次访问该watcher值重新获取新的值
         * 这样就解释了vuex中的state的对象必须提前定义好，如果state中途增加一个属性，因为
         * 该属性没有被defaneReactive，所以依赖系统没有检测到，自然不能更新
         */
        // -----------------------------------------------

        // 14.$set的实现原理
        // -----------------------------------------------

        // 15.做过那些性能优化
        // -----------------------------------------------

        // 16.重排和重绘
        /**
         * 重排负责元素的几何属性更新，
         * 重绘负责元素的样式更新
         * 重排必然带来重绘
         * 但是重绘未必带来重排
         * 比如说改变某个元素的背景，不涉及到元素的几何属性，
         * 所以只会发生重绘
         */
        // -----------------------------------------------

        // 17.vue自定义指令
        /**
         * vue.directive('focus',{
         *  inserted: function(el) {
         *  el.focus()
         * }
         * })
         */
        // -----------------------------------------------

        // 18.vue传值的方式
        /**
         * props
         * $emit
         * 
         * $attrs $listener
         * 
         * $parentNode $childNode
         * 
         * $ref
         * 
         * paovide inject
         * 
         * $eventbus
         * 
         * vuex
         */
        // -----------------------------------------------

        // 19.webpack loader的使用方式
        // -----------------------------------------------

        // 20.webpack 插件的使用方式
        /**
         * plugins: [new HtmlWebpackPlugin()]
         * 
         */
        // -----------------------------------------------

        // 21.防抖 
        // -----------------------------------------------

        // 22.闭包
        // -----------------------------------------------

        // 23.箭头函数和普通函数的区别
        // -----------------------------------------------

        // 24.居中的几种方式
        // -----------------------------------------------

        // 25.浮动和绝对定位都脱离文档流 两者的区别
        /**
         * 使用float脱离文档流时，其他盒子会无视这个元素，但是其他盒子内的文本
         * 依然会为这个元素让出位置，环绕在周围
         * 使用postion：absolute脱离文档流，其他盒子和其他盒子内的文本都会无视它
         */
        // -----------------------------------------------

        // 26.flex布局
        // -----------------------------------------------

        // 27.订阅发布模式
        /**
         * 先发布
         * 优点是无需过多关注对象在异步运行期间的内部状态，而需要订阅感兴趣的时间即可
         * 
         * 
         */
        // -----------------------------------------------

        // 28.是否写过vue插件
        /**
         * 首先把插件的模版写好.vue文件
         * 然后创建一个空对象，这个对象就是日后要使用的插件名字，此外这个对象要有
         * 一个install函数
         * 使用vue的extend方法创建一个插件的构造函数（可以看作创建了一个vue的
         * 子类）实例化该子类
         * 之后所有的操作都是通过这个子类完成
         * 
         */
        // -----------------------------------------------

        // 29.cookie 和 loacalstorage 和 sessionstorage的区别
        // -----------------------------------------------

        // 30.盒模型
        // -----------------------------------------------

        // 31.基本数据类型和引用数据类型的区别
        // -----------------------------------------------
        // 32.做过那些性能优化
        // -----------------------------------------------

        // 33.常用的es6有哪些
        /**
         * let与块级作用域
         * const
         * 对象的解构
         * 数组的解构
         * 剩余参数
         * 展开运算符
         * 箭头函数
         * object.assign
         * proxy
         * promise
         * class extends
         * set
         * 
         */



        // -----------------------------------------------
        //call在大于三个参数的时候性能会比apply高一点点
        // function fn3(x, y, z) {

        // }
        // let arr3 = [1, 2, 3]
        // let obj3 = {
        //     x: 1,
        //     y: 2,
        //     z: 3
        // }
        // fn3.apply(obj3, arr3)
        // fn3.call(obj3, ...arr3)
        
        
        
        //--------------------------------------
        // 测试执行一段代码需要多少时间
        // console.time('A')
        // for (let i = 0; i < 1000000; i++) {

        // }
        // console.timeEnd('A')

        //---------------------------
        /*
        如果是在火狐浏览器,就用console.profile(),但是要安装fireBug
        */


       //------------------------------------
       //实现(5).add(3).minus(2) ,使其输出结果为6
       ~function() {
           function check(n) {
               n = Number(n)
               return isNaN(n) ? 0 : n
           }
           function add (n) {
               n = check(n)
               return this+n
           }
           function minus(n) {
               n = check(n)
               return this-n
           }
           ['add','minus'].forEach(item => {
               Number.prototype[item] = eval(item)
           })
       }
    </script>
</body>

</html>