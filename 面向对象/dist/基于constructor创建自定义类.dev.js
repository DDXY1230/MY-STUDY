"use strict";

//基于构造函数创建自定义类,一般把单词类命大写,约定成俗的
//构造函数的设计模式,主要用于组件、插件、类库、框架的封装,平时业务逻辑用的不多
function Fn() {} // 每个实例之间互不影响


var f1 = new Fn();
var f2 = new Fn(); // js中创建值的方式有两种方式: 1.字面量方式, 2.构造函数方式
//基本数据类型基于两种不同模式创建出来的值类型是不一样的,但是都可以用数字类提供的方法

var num1 = 12; // typyof num1  => 'number'

var num2 = new Number(12); // typeof num2 => 'object'
// ==============================================

function Fn1() {}
/**
 * Fn1()
 * 普通函数执行
 * 1.形成一个私有的作用域
 * 2.形参赋值
 * 3.变量提升
 * 4.代码执行
 * 5.栈内存释放问题
 * 
 */


function Fn2() {//return // 这样只写return,是结束代码的作用,并且不会覆盖返回的实例
  // return 12
  // return {name: 'aa'} // 如果有return 引用,那么instanceof检测不出来
}

var fn21 = new Fn2(); // =》 new Fn2  如果创建实例的时候不需要传参数,那么加不加小括号都没有太大的影响

/**
 * 
 * 构造函数执行不写return,浏览器会默认返回创建的实例,但是如果自己写了return,return的是一个基本是会被忽略,返回的结果任然是类的实例,没有受到任何影响
 * 但是要是返回的是一个引用值,会把默认的实例给覆盖,此时接受到的是返回的结果不再是实例了
 */

/**
 * 查看一个实例是否是某个构造函数的实例,那么可以用instanceof
 */

console.log(fn21 instanceof Fn2);
console.log(1 instanceof Number); //false   子面量的检测不出来
//----------------------------
// in: 检测当前对象是否存在某个属性(不管当前这个属性是对象的私有属性,还是公有属性,只要有结果都会返回true)
// hasOwnProperty: 检测当前对象是否为对象的私有属性(不仅要有这个属性,而且必须还要有私有的才可以)

function hasPubProperty(obj, attr) {}